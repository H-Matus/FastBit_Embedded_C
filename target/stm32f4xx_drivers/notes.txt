To create a driver for a specific board:
1. Create a board level header (stm32f407xx.h)
    Place all base addresses for:
        1. Memory (SRAM, FLASH ROM, ROM)
        2. Buses in use (AHBx, APBx, etc.)
    Define peripheral addresses on each bus.
    Define peripheral register definition structures.
    Define clock register definition structure.
    Define peripherals (and clock) using peripheral addresses (while pointing to register definition)
    Create a clock definition;
    Define clock enable macros for peripherals by setting the correct bit on bus enable register which is pointed at by clock base address pointer (RCC->);
    Define clock disable macros.
    Define generic macros.
2. Create peripheral specific header (stm32f407xx_gpio_driver.h)
    Define config struct for peripheral (GPIO pins)
    Define handler struct for peripheral
    Define mode macros.
        For all registers that are to be used: MODE, TYPE, etc.
    Define peripheral function prototypes.
3. Create peripheral specific source
    Write the logic for peripheral functions.


GPIO_Init():

GPIO handler structure consists of the actual register address and GPIO pin config.
The config is used to take the data from user input on which GPIOs should be used and how.
Then during Init(), the config is passed into the register.

Before setting the GPIO register, we need to clear the value from the pin bits, which shall be set.


GPIO_DeInit():

We are aiming to reset all registers, for which we will be using the bus (AHBx, APBx) peripheral reset register.
In reset register, I need to set the bit of the register and revert it to 0 quickly.
Otherwise the register will be in reset state always.

do while loop is used to execute multiple statements in function macro.


GPIO_ReadFromInputPin():

Right shift the register until the required bit is the LSB. Mask it using 0x00000001 to get only the required bit.
And pass it out of the function.

GPIO Interrupts:

If the interrupt is registered and the CPU is already running an ISR, then priority will be compared.
The ISR with higher priority will be executed. If the running ISR is of lower priority, it will be put on hold.

Even if the interrupt is disabled, the interrupt arrives and gets registered in the Pending Register (PR),
though the ISR will not be executed.

Action steps of implementing an ISR function:
    1. Implement the ISR function. (just a C function)
    2. Store the address of your ISR at the vector address location corresponding to the IRQ number, for which you have written the ISR.

Weak ISRs:
A lot of ISRs have already been implemented as weak ISRs in startup code, which means that I have to override them manually.

ISRs should be implemented in the application level.
I should use the IRQ handler name based on the ones defined in startup code, as function name and inside of it, call the 
according peripheral IRQHandling().

Example:
void EXTI0_IRQHandler(void)
{
    GPIO_IRQHandling(0); /* 0 is the pin number, which will be detecting interrupt requests (IRQs) */
}

The address of EXTI0_IRQHandler() function should be stored at the vector address of the corresponding IRQ number.


STM32 GPIO Pin Specifications:
Vdd is the main power supply of the micrcontroller. Provided externally through Vdd pins of the microcontroller.
Vdd is 1.8V <= Vdd <= 3.6V; Max Voltage = 4V.
Vss is ground reference and should be kept at 0V. Minimum Vss is -0.3V.

Most pins on STM32 boards are either TT (Three-volt Tolerant) or FT (Five-volt Tolerant) pins.
Three-volt Tolerant pins are operating under -0.3V <= Vin(TTa) <= Vdd+0.3V

I/O source current is 25mA Max.

Sink current is a max current which can be sunk in to Vss by a GPIO output pin when LOW.
Sink current is 25 mA. If it's more then the pin might get damaged.
Ivdd is 240 mA, so the maximum current drawn by all pins can be 240 mA.
If I configure board pins to output 1 on 20 pins, then each pin will output 12mA of current, as 240/20 = 12.
The sum of all currents that are being sinked, has to be lower than 240 mA.

Injection current is the current that is being forced into a pin by an input voltage (Vin) higher than the positive supply (Vdd) or lower than ground (Vss).
Injection current higher than given specification causes a current flow inside the device and affects its reliability. Even tiny current exceeding the specified
limit is not allowed.

Negative-injection current is the current induced when Vin < Vss.
The maximum negative injected current is -5mA, and the minimum Vin voltage level acceptable on the GPIO is -0.3V for TT and FT GPIO.

Positive-injection current is the current induced when Vin > Vdd.
For STM32 devices, the max positive-injection current on FT GPIO is defined as N/A or 0 mA.

===================================================================================================================
SPI:

SPI is used to communicate between the MCU and peripherals, such as sensors, EEPROM, SDCard, display, Bluetooth, etc.
It has 4 lines:
    1. SCLK - clock
    2. MOSI - output
    3. MISO - input
    4. SS - slave select - selects which peripheral the MCU is talking to.

===================================================================================================================
Three-state logic:

Tri-state allows an output or input pin/pad to assume a high impedance state, which basically disconnects the pin/pad from the external circuit,
in addition to the 0 and 1 logic levels.

This allows multiple circuits to share the same output line or lines. (Like a bus which cannot listen to more than one device at a time)

===================================================================================================================

SPI (continued):

Communication protocols such as I2C, SPI, USB, etc. have 3 different types of data transmitting or receiving methodologies:
    1. Polling based (blocking call)
    2. Interrupt based (non-blocking type call)
    3. DMA based

Each of the peripheral has one or two control registers.

In the reference manual, communication peripheral control registers have a BR bit field, which stands for Baudrate.
It defines at what speed the peripheral is operating.

MSTR will be 0 by default, which means that the peripheral will be configured in peripheral mode automatically.
I have to make it as 1 in order to make my peripheral a Main. Only when I make it as a Main, it will produce the serial clock.
DEBUGGING TIP: If I see that the peripheral is not producing clock, then it should be in peripheral/slave mode.
