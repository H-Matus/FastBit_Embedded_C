To create a driver for a specific board:
1. Create a board level header (stm32f407xx.h)
    Place all base addresses for:
        1. Memory (SRAM, FLASH ROM, ROM)
        2. Buses in use (AHBx, APBx, etc.)
    Define peripheral addresses on each bus.
    Define peripheral register definition structures.
    Define clock register definition structure.
    Define peripherals (and clock) using peripheral addresses (while pointing to register definition)
    Create a clock definition;
    Define clock enable macros for peripherals by setting the correct bit on bus enable register which is pointed at by clock base address pointer (RCC->);
    Define clock disable macros.
    Define generic macros.
2. Create peripheral specific header (stm32f407xx_gpio_driver.h)
    Define config struct for peripheral (GPIO pins)
    Define handler struct for peripheral
    Define mode macros.
        For all registers that are to be used: MODE, TYPE, etc.
    Define peripheral function prototypes.
3. Create peripheral specific source
    Write the logic for peripheral functions.


GPIO_Init():

GPIO handler structure consists of the actual register address and GPIO pin config.
The config is used to take the data from user input on which GPIOs should be used and how.
Then during Init(), the config is passed into the register.

Before setting the GPIO register, we need to clear the value from the pin bits, which shall be set.


GPIO_DeInit():

We are aiming to reset all registers, for which we will be using the bus (AHBx, APBx) peripheral reset register.
In reset register, I need to set the bit of the register and revert it to 0 quickly.
Otherwise the register will be in reset state always.

do while loop is used to execute multiple statements in function macro.


GPIO_ReadFromInputPin():

Right shift the register until the required bit is the LSB. Mask it using 0x00000001 to get only the required bit.
And pass it out of the function.

GPIO Interrupts:

If the interrupt is registered and the CPU is already running an ISR, then priority will be compared.
The ISR with higher priority will be executed. If the running ISR is of lower priority, it will be put on hold.

Even if the interrupt is disabled, the interrupt arrives and gets registered in the Pending Register (PR),
though the ISR will not be executed.

Action steps of implementing an ISR function:
    1. Implement the ISR function. (just a C function)
    2. Store the address of your ISR at the vector address location corresponding to the IRQ number, for which you have written the ISR.

Weak ISRs:
A lot of ISRs have already been implemented as weak ISRs in startup code, which means that I have to override them manually.

ISRs should be implemented in the application level.
I should use the IRQ handler name based on the ones defined in startup code, as function name and inside of it, call the 
according peripheral IRQHandling().

Example:
void EXTI0_IRQHandler(void)
{
    GPIO_IRQHandling(0); /* 0 is the pin number, which will be detecting interrupt requests (IRQs) */
}

The address of EXTI0_IRQHandler() function should be stored at the vector address of the corresponding IRQ number.


STM32 GPIO Pin Specifications:
Vdd is the main power supply of the micrcontroller. Provided externally through Vdd pins of the microcontroller.
Vdd is 1.8V <= Vdd <= 3.6V; Max Voltage = 4V.
Vss is ground reference and should be kept at 0V. Minimum Vss is -0.3V.

Most pins on STM32 boards are either TT (Three-volt Tolerant) or FT (Five-volt Tolerant) pins.
Three-volt Tolerant pins are operating under -0.3V <= Vin(TTa) <= Vdd+0.3V

I/O source current is 25mA Max.

Sink current is a max current which can be sunk in to Vss by a GPIO output pin when LOW.
Sink current is 25 mA. If it's more then the pin might get damaged.
Ivdd is 240 mA, so the maximum current drawn by all pins can be 240 mA.
If I configure board pins to output 1 on 20 pins, then each pin will output 12mA of current, as 240/20 = 12.
The sum of all currents that are being sinked, has to be lower than 240 mA.

Injection current is the current that is being forced into a pin by an input voltage (Vin) higher than the positive supply (Vdd) or lower than ground (Vss).
Injection current higher than given specification causes a current flow inside the device and affects its reliability. Even tiny current exceeding the specified
limit is not allowed.

Negative-injection current is the current induced when Vin < Vss.
The maximum negative injected current is -5mA, and the minimum Vin voltage level acceptable on the GPIO is -0.3V for TT and FT GPIO.

Positive-injection current is the current induced when Vin > Vdd.
For STM32 devices, the max positive-injection current on FT GPIO is defined as N/A or 0 mA.

===================================================================================================================
SPI:

SPI is used to communicate between the MCU and peripherals, such as sensors, EEPROM, SDCard, display, Bluetooth, etc.
It has 4 lines:
    1. SCLK - clock
    2. MOSI - output
    3. MISO - input
    4. SS - slave select - selects which peripheral the MCU is talking to.

===================================================================================================================
Three-state logic:

Tri-state allows an output or input pin/pad to assume a high impedance state, which basically disconnects the pin/pad from the external circuit,
in addition to the 0 and 1 logic levels.

This allows multiple circuits to share the same output line or lines. (Like a bus which cannot listen to more than one device at a time)

===================================================================================================================

SPI (continued):

Communication protocols such as I2C, SPI, USB, etc. have 3 different types of data transmitting or receiving methodologies:
    1. Polling based (blocking call)
    2. Interrupt based (non-blocking type call)
    3. DMA based

Each of the peripheral has one or two control registers.

In the reference manual, communication peripheral control registers have a BR bit field, which stands for Baudrate.
It defines at what speed the peripheral is operating.

MSTR will be 0 by default, which means that the peripheral will be configured in peripheral mode automatically.
I have to make it as 1 in order to make my peripheral a Main. Only when I make it as a Main, it will produce the serial clock.
DEBUGGING TIP: If I see that the peripheral is not producing clock, then it should be in peripheral/slave mode.

If I want a simplex communication, then I may have to check the 10th bit, as it describes RX ONLY bit.
Some bits are combined like RXONLY, BIDI MODE, BIDIOE:
    1. BIDI MODE defines if bidirectional data is enabled or 2 line unidirectional is enabled.
    2. BIDIOE defines whether the direction is RX or TX (this only works with bidirectional mode).
    3. RXONLY is combined with BIDI MODE in 2-line unidirectional mode to say whether the mode is Full duplex or output is disabled (RX only).

If I want to have SIMPLEX only communication, I have to make RXONLY bit as 1.

FULL DUPLEX communication has 2 unidirectional lines:
    1. MISO -> MISO
    2. MOSI -> MOSI

To make SIMPLEX out of FULL DUPLEX just disconnect the MISO line.
To make SIMPLEX receive only out of FULL DUPLEX, we can't just disconnect the MOSI line, we have to activate the SCLK line as well.
    In SPI Communication, slave will not initiate data transfer unless master produces clock.

Since the MOSI is deactivated, master will not produce clock on serial clock, because in SPI communication, the clock is produced 
only when data is produced on the MOSI line.
Because of this we have to force the main to produce clock on SCLK.
We do that by setting the RXONLY bit, to the receive only mode.

Software Peripheral Management (SSM) is disabled by default, which means that peripherals are selected using hardware wires.

=========================================================================================================================================================
SPI Init:
The device mode is defined in MSTR bit field of Control Register (CR1).

SPI Data Send:
Firmware does not have access to buffers, thus it is accessed by using SPI_DR register (Data Register).
In receiving mode, the data comes from RX buffer into the Data Register from where the firmware reads it.
In transmission mode, the data from Data Register is copied over to the TX buffer.
Before writing to the Data Register, make sure that the TX buffer is empty - check the TXE flag and before reading the register, check the RXNE flag.

Write SPI flags under the spi_driver.h

I2C requires GPIO open drain configuration, while SPI doesn't require anything, thus push-pull shall be used for SPI with no pull-up/pull-down config.

To send data via SPI, both GPIO and SPI must be initialised.

After SPI2_Inits(), all the required configurations are loaded into the control registers, but the SPI peripheral is not enabled because of that.
The SPI configs must be loaded into registers, while the SPI is disabled.
We have to explicitly enable SPI, by enabling the SPE bit in SPIx_CR. SPE is 0 by default.
When you enable SPI peripheral, the SPI peripheral will be busy in data communcation, in which case the SPI peripheral will not accept any changes
    made to the control registers.

=========================================================================================================================================================
SPI Receive Data:
Process of receiving data on SPI:
    1. Check if Len is 0;
        Yes: Exit from the function and end;
        No: Wait until the Rx Buffer is non-empty;
    2. What value is DFF?:
        0: Read Data Register for 1 byte of data and increment the rx buffer address
            Then decrement Len, as one 1 byte has been read.
        1: Read Data Register for 2 bytes of data and increment the rx buffer address
            Then decrement Len twice, as 2 bytes if data have been read.
    3. Return to 1.

=========================================================================================================================================================
SPI Interrupts:
During SPI communication, interrupts can be generated by the following events:
    1. Transmit Tx buffer ready to be loaded
    2. Data received in Rx buffer
    3. Master mode fault (in single master case you must avoid this error happening)
    4. Overrun error

Interrupts can be enabled and disabled separately.

Master mode fault may occur when the SPI comms are used in multi-master configuration.
Overrun error flag may be set up in the status register and interrupts may be triggered.

The control register controls during which events the interrupt shall be triggered.
If TXEIE is set to 1 in control register, then the interrupt will be triggered when the TXE is set.
By default, TXEIE is 0, which means that by default TXE flag will not set off an interrupt.

SPI_1 is connected to NVIC at some IRQ number. If we have 5 SPI peripherals, then we will have 5 different IRQ lines connected to NVIC.
=========================================================================================================================================================
