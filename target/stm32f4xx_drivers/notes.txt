To create a driver for a specific board:
1. Create a board level header (stm32f407xx.h)
    Place all base addresses for:
        1. Memory (SRAM, FLASH ROM, ROM)
        2. Buses in use (AHBx, APBx, etc.)
    Define peripheral addresses on each bus.
    Define peripheral register definition structures.
    Define clock register definition structure.
    Define peripherals (and clock) using peripheral addresses (while pointing to register definition)
    Create a clock definition;
    Define clock enable macros for peripherals by setting the correct bit on bus enable register which is pointed at by clock base address pointer (RCC->);
    Define clock disable macros.
    Define generic macros.
2. Create peripheral specific header (stm32f407xx_gpio_driver.h)
    Define config struct for peripheral (GPIO pins)
    Define handler struct for peripheral
    Define mode macros.
        For all registers that are to be used: MODE, TYPE, etc.
    Define peripheral function prototypes.
3. Create peripheral specific source
    Write the logic for peripheral functions.


GPIO_Init():

GPIO handler structure consists of the actual register address and GPIO pin config.
The config is used to take the data from user input on which GPIOs should be used and how.
Then during Init(), the config is passed into the register.

Before setting the GPIO register, we need to clear the value from the pin bits, which shall be set.


GPIO_DeInit():

We are aiming to reset all registers, for which we will be using the bus (AHBx, APBx) peripheral reset register.
In reset register, I need to set the bit of the register and revert it to 0 quickly.
Otherwise the register will be in reset state always.

do while loop is used to execute multiple statements in function macro.


GPIO_ReadFromInputPin():

Right shift the register until the required bit is the LSB. Mask it using 0x00000001 to get only the required bit.
And pass it out of the function.

GPIO Interrupts:

If the interrupt is registered and the CPU is already running an ISR, then priority will be compared.
The ISR with higher priority will be executed. If the running ISR is of lower priority, it will be put on hold.

Even if the interrupt is disabled, the interrupt arrives and gets registered in the Pending Register (PR),
though the ISR will not be executed.

Action steps of implementing an ISR function:
    1. Implement the ISR function. (just a C function)
    2. Store the address of your ISR at the vector address location corresponding to the IRQ number, for which you have written the ISR.

Weak ISRs:
A lot of ISRs have already been implemented as weak ISRs in startup code, which means that I have to override them manually.

ISRs should be implemented in the application level.
I should use the IRQ handler name based on the ones defined in startup code, as function name and inside of it, call the 
according peripheral IRQHandling().

Example:
void EXTI0_IRQHandler(void)
{
    GPIO_IRQHandling(0); /* 0 is the pin number, which will be detecting interrupt requests (IRQs) */
}

The address of EXTI0_IRQHandler() function should be stored at the vector address of the corresponding IRQ number.


STM32 GPIO Pin Specifications:
Vdd is the main power supply of the micrcontroller. Provided externally through Vdd pins of the microcontroller.
Vdd is 1.8V <= Vdd <= 3.6V; Max Voltage = 4V.
Vss is ground reference and should be kept at 0V.
