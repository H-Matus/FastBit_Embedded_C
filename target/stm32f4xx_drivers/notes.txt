To create a driver for a specific board:
1. Create a board level header (stm32f407xx.h)
    Place all base addresses for:
        1. Memory (SRAM, FLASH ROM, ROM)
        2. Buses in use (AHBx, APBx, etc.)
    Define peripheral addresses on each bus.
    Define peripheral register definition structures.
    Define clock register definition structure.
    Define peripherals (and clock) using peripheral addresses (while pointing to register definition)
    Create a clock definition;
    Define clock enable macros for peripherals by setting the correct bit on bus enable register which is pointed at by clock base address pointer (RCC->);
    Define clock disable macros.
    Define generic macros.
2. Create peripheral specific header (stm32f407xx_gpio_driver.h)
    Define config struct for peripheral (GPIO pins)
    Define handler struct for peripheral
    Define mode macros.
        For all registers that are to be used: MODE, TYPE, etc.
    Define peripheral function prototypes.
3. Create peripheral specific source
    Write the logic for peripheral functions.


GPIO_Init():

GPIO handler structure consists of the actual register address and GPIO pin config.
The config is used to take the data from user input on which GPIOs should be used and how.
Then during Init(), the config is passed into the register.

Before setting the GPIO register, we need to clear the value from the pin bits, which shall be set.


GPIO_DeInit():

We are aiming to reset all registers, for which we will be using the bus (AHBx, APBx) peripheral reset register.
In reset register, I need to set the bit of the register and revert it to 0 quickly.
Otherwise the register will be in reset state always.

do while loop is used to execute multiple statements in function macro.


GPIO_ReadFromInputPin():

Right shift the register until the required bit is the LSB. Mask it using 0x00000001 to get only the required bit.
And pass it out of the function.

GPIO Interrupts:

If the interrupt is registered and the CPU is already running an ISR, then priority will be compared.
The ISR with higher priority will be executed. If the running ISR is of lower priority, it will be put on hold.

Even if the interrupt is disabled, the interrupt arrives and gets registered in the Pending Register (PR),
though the ISR will not be executed.

Action steps of implementing an ISR function:
    1. Implement the ISR function. (just a C function)
    2. Store the address of your ISR at the vector address location corresponding to the IRQ number, for which you have written the ISR.

Weak ISRs:
A lot of ISRs have already been implemented as weak ISRs in startup code, which means that I have to override them manually.

ISRs should be implemented in the application level.
I should use the IRQ handler name based on the ones defined in startup code, as function name and inside of it, call the 
according peripheral IRQHandling().

Example:
void EXTI0_IRQHandler(void)
{
    GPIO_IRQHandling(0); /* 0 is the pin number, which will be detecting interrupt requests (IRQs) */
}

The address of EXTI0_IRQHandler() function should be stored at the vector address of the corresponding IRQ number.


STM32 GPIO Pin Specifications:
Vdd is the main power supply of the micrcontroller. Provided externally through Vdd pins of the microcontroller.
Vdd is 1.8V <= Vdd <= 3.6V; Max Voltage = 4V.
Vss is ground reference and should be kept at 0V. Minimum Vss is -0.3V.

Most pins on STM32 boards are either TT (Three-volt Tolerant) or FT (Five-volt Tolerant) pins.
Three-volt Tolerant pins are operating under -0.3V <= Vin(TTa) <= Vdd+0.3V

I/O source current is 25mA Max.

Sink current is a max current which can be sunk in to Vss by a GPIO output pin when LOW.
Sink current is 25 mA. If it's more then the pin might get damaged.
Ivdd is 240 mA, so the maximum current drawn by all pins can be 240 mA.
If I configure board pins to output 1 on 20 pins, then each pin will output 12mA of current, as 240/20 = 12.
The sum of all currents that are being sinked, has to be lower than 240 mA.

Injection current is the current that is being forced into a pin by an input voltage (Vin) higher than the positive supply (Vdd) or lower than ground (Vss).
Injection current higher than given specification causes a current flow inside the device and affects its reliability. Even tiny current exceeding the specified
limit is not allowed.

Negative-injection current is the current induced when Vin < Vss.
The maximum negative injected current is -5mA, and the minimum Vin voltage level acceptable on the GPIO is -0.3V for TT and FT GPIO.

Positive-injection current is the current induced when Vin > Vdd.
For STM32 devices, the max positive-injection current on FT GPIO is defined as N/A or 0 mA.

===================================================================================================================
SPI:

SPI is used to communicate between the MCU and peripherals, such as sensors, EEPROM, SDCard, display, Bluetooth, etc.
It has 4 lines:
    1. SCLK - clock
    2. MOSI - output
    3. MISO - input
    4. SS - slave select - selects which peripheral the MCU is talking to.

===================================================================================================================
Three-state logic:

Tri-state allows an output or input pin/pad to assume a high impedance state, which basically disconnects the pin/pad from the external circuit,
in addition to the 0 and 1 logic levels.

This allows multiple circuits to share the same output line or lines. (Like a bus which cannot listen to more than one device at a time)

===================================================================================================================

SPI (continued):

Communication protocols such as I2C, SPI, USB, etc. have 3 different types of data transmitting or receiving methodologies:
    1. Polling based (blocking call)
    2. Interrupt based (non-blocking type call)
    3. DMA based

Each of the peripheral has one or two control registers.

In the reference manual, communication peripheral control registers have a BR bit field, which stands for Baudrate.
It defines at what speed the peripheral is operating.

MSTR will be 0 by default, which means that the peripheral will be configured in peripheral mode automatically.
I have to make it as 1 in order to make my peripheral a Main. Only when I make it as a Main, it will produce the serial clock.
DEBUGGING TIP: If I see that the peripheral is not producing clock, then it should be in peripheral/slave mode.

If I want a simplex communication, then I may have to check the 10th bit, as it describes RX ONLY bit.
Some bits are combined like RXONLY, BIDI MODE, BIDIOE:
    1. BIDI MODE defines if bidirectional data is enabled or 2 line unidirectional is enabled.
    2. BIDIOE defines whether the direction is RX or TX (this only works with bidirectional mode).
    3. RXONLY is combined with BIDI MODE in 2-line unidirectional mode to say whether the mode is Full duplex or output is disabled (RX only).

If I want to have SIMPLEX only communication, I have to make RXONLY bit as 1.

FULL DUPLEX communication has 2 unidirectional lines:
    1. MISO -> MISO
    2. MOSI -> MOSI

To make SIMPLEX out of FULL DUPLEX just disconnect the MISO line.
To make SIMPLEX receive only out of FULL DUPLEX, we can't just disconnect the MOSI line, we have to activate the SCLK line as well.
    In SPI Communication, slave will not initiate data transfer unless master produces clock.

Since the MOSI is deactivated, master will not produce clock on serial clock, because in SPI communication, the clock is produced 
only when data is produced on the MOSI line.
Because of this we have to force the main to produce clock on SCLK.
We do that by setting the RXONLY bit, to the receive only mode.

Software Peripheral Management (SSM) is disabled by default, which means that peripherals are selected using hardware wires.

=========================================================================================================================================================
SPI Init:
The device mode is defined in MSTR bit field of Control Register (CR1).

SPI Data Send:
Firmware does not have access to buffers, thus it is accessed by using SPI_DR register (Data Register).
In receiving mode, the data comes from RX buffer into the Data Register from where the firmware reads it.
In transmission mode, the data from Data Register is copied over to the TX buffer.
Before writing to the Data Register, make sure that the TX buffer is empty - check the TXE flag and before reading the register, check the RXNE flag.

Write SPI flags under the spi_driver.h

I2C requires GPIO open drain configuration, while SPI doesn't require anything, thus push-pull shall be used for SPI with no pull-up/pull-down config.

To send data via SPI, both GPIO and SPI must be initialised.

After SPI2_Inits(), all the required configurations are loaded into the control registers, but the SPI peripheral is not enabled because of that.
The SPI configs must be loaded into registers, while the SPI is disabled.
We have to explicitly enable SPI, by enabling the SPE bit in SPIx_CR. SPE is 0 by default.
When you enable SPI peripheral, the SPI peripheral will be busy in data communcation, in which case the SPI peripheral will not accept any changes
    made to the control registers.

=========================================================================================================================================================
SPI Receive Data:
Process of receiving data on SPI:
    1. Check if Len is 0;
        Yes: Exit from the function and end;
        No: Wait until the Rx Buffer is non-empty;
    2. What value is DFF?:
        0: Read Data Register for 1 byte of data and increment the rx buffer address
            Then decrement Len, as one 1 byte has been read.
        1: Read Data Register for 2 bytes of data and increment the rx buffer address
            Then decrement Len twice, as 2 bytes if data have been read.
    3. Return to 1.

=========================================================================================================================================================
SPI Interrupts:
During SPI communication, interrupts can be generated by the following events:
    1. Transmit Tx buffer ready to be loaded
    2. Data received in Rx buffer
    3. Master mode fault (in single master case you must avoid this error happening)
    4. Overrun error

Interrupts can be enabled and disabled separately.

Master mode fault may occur when the SPI comms are used in multi-master configuration.
Overrun error flag may be set up in the status register and interrupts may be triggered.

The control register controls during which events the interrupt shall be triggered.
If TXEIE is set to 1 in control register, then the interrupt will be triggered when the TXE is set.
By default, TXEIE is 0, which means that by default TXE flag will not set off an interrupt.

SPI_1 is connected to NVIC at some IRQ number. If we have 5 SPI peripherals, then we will have 5 different IRQ lines connected to NVIC.

=========================================================================================================================================================
SPI ISR handling:
    1. Enter ISR
    2. Understand which event caused interrupt to trigger (check SR)
        a. Interrupt is due to setting of RXNE flag -> Handle RXNE event
        b. Interrupt is due to setting of TXE flag -> Handle TXE flag
        c. Interrupt is due Setting of ERROR flag -> Handle Error

Handling TXE Interrupt:
    1. 8-bit or 16-bit mode?
        8-bit: Write one byte to SPI Data Register (DR) -> Decrement Len by 1
        16-bit: Write 2 byte to SPI Data Register (DR) -> Decrement Len by 2
    2. Is Len = 0?
        Yes: Close the SPI TX
        No: Wait till another TXE interrupt

=========================================================================================================================================================
Overrun error definition:
Overrun condition occurs when the master or the slave completes the reception of the next data frame,
while the read operation of the previous frame from the Rx buffer has not completed (case RXNE flag is set).
In such case the SPI peripheral will discard the new data byte that is arrived and we will lose the data.

Read operation of SPI_DR returns the frame previously received.

To clear the OVR bit, we need to perform read access to the SPI_DR register followed by a read access to the SPI_SR register.

(Private functions should have their prototypes in source files (.c), as they are not supposed to be used as API by users)

After operations with temp variable, I can typecast it to (void), as it is unused.

=========================================================================================================================================================
Common Problems with SPI and debugging tips:

Master moed bit must be enabled in the configuration register if you are configurating the peripheral as master.
SPI peripheral enable bit must be enabled.
SPI peripheral clock must be enabled. By default clocks to almost all peripheral in the microcontroller will be disabled to save power.

Cases:
    1. Master is not able to produce clock and data.
        a. GPIOs are not configured properly for SPI (Alternate) functionality -> Recheck the GPIO Configuration registers to see what values they have.
        b. Because of Configuration Overriding -> Dump out all the required register contents just before you begin the transmission.
    2. Master is sending data, but slave is not receiving data;
        a. Not pulling down the slave select pin to ground before sending data to the slave -> probe through the logic analyser to confirm 
            slave select line is really low during data communication.
        b. GPIOs are not configured properly (alternate functionality) -> probe the alternate function register
        c. Not enabling the peripheral IRQ number in the NVIC -> Probe the NVIC interrupt mask register to see whether the bit position
            corresponding to the IRQ number.
    3. SPI interrupts are not getting triggered.
        a. Not enabling the TXE or RXNE interrupt in the SPI configuration register -> Check the SPI configuration register 
            to see TXEIE and RXNEIE bits are really set to enable the interrupt.
        b. Not enabling the peripheral IRQ number in the NVIC -> Probe the NVIC Interrupt Mask Register 
            to see whether the bit position corresponding to the IRQ number is set or not.
    4. Master is producing right data but slave is receiving the different data.
        a. Using long wires in high frequency communication -> use shorter wires or reduce the SPI serial frequency to 500kHz to check things work well.
        
==============================================================================================================================================================
I2C:
It is a protocol to achieve serial data communication between integrated circuits (ICs) which are very close to each other.
It's a more serious protocol than SPI because companies have come forward to design a specification for it.

I2C protocol details (how data should be sent, received, what's the handshake, error handling, etc.) are more complex than SPI. 
(SPI is simple when compared to I2C)

I2C spec is designed by NXP. SPI doesn't have a spec.

I2C protocol is multi-master capable, whereas SPI has no guidelines to achieve this, but depends on MCU designers.
STM SPI peripherals can be used in multi master configuration but arbitration should be handled by software code.

I2C hardware automatically ACKs (acknowledges) every byte received. SPI does not support any automatic ACKing.

I2C requires only 2 pins: SDA and SCL.
I2C master talks to peripherals based on peripheral addresses, whereas in SPI dedicated pin is used to select the slave.

I2C is half duplex, whereas SPI is full duplex.

I2C max speed is 4MHz in ultra speed plus mode. For some STM microcontrollers the max speed is just 400 kHz.
SPI max speed is Fpclk/2. That means if the peripheral clock is 20 MHz, then speed can be 10 MHz.

In I2C, peripheral can make controller wait by holding the clock down if it's busy, thanks to clock streching feature of I2C.
In SPI, peripheral has no control over clock, programmers may use their own tricks to overcome this situation.

Data rate is a number of bits transferred from sender to receiver in 1 sec.
SPI is a lot faster in this regard than I2C.

Terminology:
    1. Controller - the device which initiates a transfer, generates clock signals and terminates a transfer.
    2. Peripheral - the device addressed by a master.
    3. Multi-controller - more than one controller can attempt to control the bus at the same time without corrupting the message.
    4. Arbitration - procedure to ensure that, if more than one controller simultaneously tries to control the bus, only one is allowed to do so 
        and the winning message is not corrupted.
    5. Synchronization - procedure to synchronize clock signals of two or more devices.

Both SDA and SCL are bidirectional lines connected to a positive supply voltage via pull-up resistors. When the bus is free, both lines are held at HIGH.
The output stages of devices connected to the bus must have an open-drain or open-collector configuration.
The bus capacitance limits the number of interfaces connected to the bus.

For I2C pins to function properly, pull-up resistor value shall be calculated according to the I2C formula.

SDA and SCL pins have to be in Open-Drain configuration with either an internal or external pull-up resistor.

When the bus is idle, both SDA and SCL are pulled to +Vdd.
Whenever you face problems in I2C, probe the SDA and SCL lines after I2C initialisation. It must be held at HIGH. (3.3V or 1.8V)

=========================================================================================================================================================
I2C modes:
    1. Standard     - Up to 100 Kbits/s - Supported by STMf2F4x
    2. Fast         - Up to 400 Kbits/s - Supported by STMf2F4x
    3. Fast+        - Up to   1 Mbits/s - Supported by some STMf2F4x MCUs (refer to RM)
    4. High Speed   - Up to 3.4 Mbits/s - Not supported by F4x

Standard mode was the first mode released with I2C.
Standard mode devices are not upward compatible, as they can't communicate with devices of fast mode or above.

Fast-mode devices are downward-compatible and can communicate with standard-mode devices in a 0-100 kbit/s I2C bus system.
Standard-mode devices should not be introduced in a fast-mode I2C-bus system. Such introduction can cause unpredictable states.
To achieve higher data transfer rates, I2C devices shall be put in to a fast mode in configs.


=========================================================================================================================================================
Basics of I2C protocol:
The data transfer is always initiated by the controller on SDA line. 

The process of SDA:
    1. Controller initiates the data transfer by first producing the start condition.
    2. Address phase starts, during which first 7 bits is the address of the peripheral.
    3. The remaining last bit decides the read or write operation.
        If bit is 0 -> controller is going to write the data (WRITE)
        If bit is 1 -> controller is going to read the data (READ)

Every iteration put on SDA line, must be 8 bits long.
Each byte must be followed by an ACK bit.
    When peripheral gets the 8bits, it then sends back an ACK bit, which the controller receives.
    If the R/W bit is 0 (WRITE), then after ACK, peripheral receives data byte, after which the peripheral sends an ACK again, 
    saying that it received the data byte.
Data is transferred with the Most Significant Bit (MSB) first.

When controller decides to stop communication with peripheral, then STOP condition is generated.
When stop condition is generated, then the controller is no longer in control of the bus and another controller/same controller can take control of it.

Address phase is the combination of peripheral address and R/W bit.


=========================================================================================================================================================
START and STOP:
All comms begin with a START (S) and a STOP (P).

A HIGH to LOW transition on the SDA line while SCL is HIGH defines a START condition.
A LOW to HIGH transition on the SDA line while SCL is HIGH defines a STOP condition.

Once controller generates the START condition successfully it actually claims the bus so that no other controller can claim the bus.
Other controllers should wait until bus is released.

After STOP condition, both SDA and SCL are released -> they are in pull-up condition.

When SDA is low, then it is activated, because by default it is pulled high.
If the state of SDA is low at this position then it is considered as ACK otherwise it's NACK.

Repeated START (Sr) is a START condition, which did not require a stop condition to be engaged.


=========================================================================================================================================================
STOP condition timings:
Setup Time for Stop Condition (Tsu;sto) is measured as the time between 70% amplitude of the rising edge of SCL and 30% amplitude of a rising SDA signal
during a stop condition.


=========================================================================================================================================================
I2C Points to remember:
START and STOP conditions are always generated by the controller.
The bus is considered to be busy after the START condition.

The bus is considered to be free again a certain time after the STOP condition.

When the bus is free another controller(if present) can get the chance to claim the bus.

The bus stays busy if a repeated START (Sr) is generated instead of a STOP condition.

Most of the MCUs I2C peripherals support both controller and peripheral mode.
You need not to configure the mode because when the peripheral generates the start condition it automatically becomes
    the controller and when it generates the STOP condition it goes back to peripheral mode.


=========================================================================================================================================================
I2C Address Phase:
The transmitter releases the SDA line during the ACK clock pulse so the receiver can pull the SDA line LOW and it remains stable LOW
    during the HIGH period of this clock pulse.

IMPORTANT:
    1. The ACK takes place after every byte.
    2. The ACK bit allows the receiver to signal the transmitter that the byte was successfully received and another byte may be sent.
    3. The controller generates all clock pulses, includeing the ACK ninth clock pulse.

When SDA remains HIGH during this 9th clock pulse, this is defined as the NACK signal.
The controller can then generate either a STOP condition to abort the transfer, or a repeated START condition to start a new transfer.


=========================================================================================================================================================
I2C Data Validity:
The data on the SDA line must be stable during the HIGH period of the clock. The HIGH or LOW state of the data line can only change when
    the clock signal on the SCL line is LOW. One clock pulse is generated for each data bit transferred.

Data changes only when the clock is high.

How a controller is writing data to a peripheral?:
    1. Controller generates the start condition and after that comes the address phase. (7 bit address)
    2. SDA is pulled high or low based on ACK response from peripheral.
    3. After ACK, Controller writes 1 byte of data followed by ACK/NACK from peripheral.
    4. Controller keeps writing 1 byte data followed by ACK/NACK until controller initiates a stop condition (SDA goes from LOW to HIGH when SCL is HIGH)

How controller is reading data from a peripheral?:
    1. Controller generates a start condition.
    2. Controller puts peripheral address on SDA line.
    3. Controller defines the R/W bit.
    4. Peripheral puts 1 byte of data for a controller to read on the SDA line.
    5. Controller produces ACK/NACK on SDA line.
    6. Peripheral keeps sending bytes of data until it receives NACK from controller.
    7. Controller initiates a stop condition.

When peripheral receives ACK, it's an indication for the peripheral to send one more byte to controller.
When controller receives ACK, it means that the peripheral has received the data.

 
=========================================================================================================================================================
Repeated Start (Sr):
In cases when a task of a controller requires more than one read and/or write, instead of ending each data transmission with
    a stop condition, the controller can initiate a START condition again to show that the new transmission is going to take place
    and not release the bus for any other controller to claim it.

This only makes sense if the bus has multiple controllers, whereas in a single controller bus it wouldn't matter.

=========================================================================================================================================================
I2C driver APIs:
    1. I2C Init
    2. I2C Controller Tx
    3. I2C Controller Rx
    4. I2C Peripheral Tx
    5. I2C Peripheral Rx
    6. I2C Error Interrupt handling
    7. I2C Event Interrupt handling

I2Cx Peripheral Configurable items:
    1. I2C_SCLSpeed
    2. I2C_DeviceAddress
    3. I2C_ACKControl
    4. I2C_FMDutyCycle

=========================================================================================================================================================
Steps for I2C Init (Generic):
    1. Configure the Mode (standard or fast)
    2. Configure the speed of the serial clock (SCL)
    3. Configure the device address (applicable only when device is a peripheral)
    4. Enable the ACKing
    5. Configure the rise time for I2C pins 

When we use higher frequencies, we can't driver I2C bus over longer distances.
The rise time is the time for the signal to reach from ground level to the VCC level.

The peripheral must first be disabled to change the config!!!


=========================================================================================================================================================
I2C Serial Clock Config:
Value of APB bus clock goes into the I2C CR2 FREQ field.

The process of generating 100kHz clock from APB1 16MHz clock: (Standard mode)
    1. Configure the mode in CCR register (15th bit)
    2. Program FREQ field of CR2 with the value of PCLK1
    3. Calculate and Program CCR value in CCR field of CCR register

In FM mode -> process of generating 200kHz clock from APB1 16MHz clock:
    1. Configure the mode in CCR register
    2. Select the duty cycle of Fast mode SCL in CCR register
    3. Program FREQ field of CR2 with the value of PCLK1
    4. Calculate and Program CCR value in CCR field of CCR register

In fast mode, 2 types of duty cycles are possible when the mode is Fast.
In STM32F4x I2C Standard Mode -> Tlow = Thigh of the clock period.
In Fast Mode ->
    1. Tlow = 2 x Thigh
    2. Tlow = 1.8 x Thigh

According to the I2C spec, in Standard Mode Tlow is advised to be 4.7 microseconds, whereas Thigh = 4.0 microseconds (minimum).
In Fast Mode, Tlow = 1.3 uSeconds, Thigh = 0.6 uSeconds.

Refer to Section 54 in MCU1 course for calculations.


=========================================================================================================================================================
Clock Stretching:
Clock Stretching is a state when the clock is held to 0 or ground level.

The moment clock is held at low, then the whole I2C interface pauses until clock is given to its normal operation level.

I2C devices, either Controller or Peripheral, use Clock Stretching to slow down the communication by stretching SCL to low,
    which prevents the clock to rise High again and the I2C communication stops for a while.

There are situations where an I2C peripheral is not able to co-operate with the clock speed given 
    by the Controller and needs to slow down a little.

If peripheral needs time, then it takes the advantage of clock stretching and by holding clock at low,
    it momentarily pauses the I2C operation.

Clock stretching and unstretching is automatically controlled by the I2C hardware. I just have to enable it.


=========================================================================================================================================================
Clock API:
In order to set the clock speed, we need to check the CFGR register in RCC for the SWS bit (whether it is HSI, HSE, PLL or Not Applicable)
    and then assign the local variable to a correct Hz number based on the board clock calculation (e.g. HSE = 8 MHz).

The PLL must be calculated by the driver.

It's good to mask tempregs based on what bit fields are configured on for safety purposes.

=========================================================================================================================================================

If something is controlled by an application, then I have to copy the I2C Config from I2C Handle into a tempreg, which then shall be passed into
a proper register in I2Cx peripheral, which is in I2C Handle.

=========================================================================================================================================================
I2C Send Data:

Whoever initiates the data transfer first, becomes the controller.
When a START condition is successfully triggered, then Event 5 will happen in STM32 MCU.
    Event 5 sets the start bit to 1 in the Status Register.
    This means that Controller has to wait until the SB becomes 1 to move to the address phase.
When the Controller executes Address Phase, then the EV5 or SB1 will be automatically cleared.

P.S. EV5, EV6, EV9, EV8_1 and EV8_2 events stretch SCL low until the end of the corresponding software sequence.
    (Clock will be pulled low until SB is cleared)

When the Address Phase is executed, ACK Phase takes place and ACK will only be set if the peripheral with corresponding address is on the bus.
If ACK is received, then EV6 will happen, which means that ADDR of the Status Register will be set to 1. 
    (If ADDR = 1, then peripheral received the request)
    Setting ADDR = 1, also can stretch the clock to LOW.

As soon as ADDR flag is cleared, EV8_1 will be executed.
EV8_1 sets TxE to 1 and it means that shift register and data register are empty. It is cleared once the Data1 is written.
    The data will be immediately copied into the shift register.

Afterwards, EV8 will happen immediately, which means that:
    TxE = 1
    Shift register is not empty because it is transmitting data
    data register is empty because the data was copied into the shift register
    TxE is cleared by writing in Data Register, which means that it will be cleared when a new data byte is going to be written.
Afterwards, Controller waits for ACK and once it is received, the Data 2, which has been written into DR during the time Data 1 is being transmitted,
    will be moved to the shift register.

And then Data 2 transmission begins, because TxE is set -> EV8 is executed.

TxE means that the Data Register is empty and software is allowed to write the data into the Data Register without any corruption of data.

In I2C, TxE is set only when data is successfully sent and ACK is received.

After the last byte transmission, we receive an ACK and we have to wait until EV8_2 event.
    We have to wait until TxE = 1
    And we have to wait until BTF = 1
    Once these two flags are set, we can initiate program stop request
    TxE and BTF are cleared by hardware by the stop condition.

BTF is a bit in SR, which says whether the Data Byte transfer is finished. (Read more in the reference manual)
When both TxE = 1 and Data Register is NULL, and Shift Register, 
    then BTF becomes 1 and clock will be stretched to avoid under run error during transmission.

=========================================================================================================================================================
I2C Pull-up Resistance

In I2C, LOW-level output voltage is considered to be from 0V to 0.4V. 

To get Vol for pull-up resistance calculation, go to page 47 of I2C specification and check Table 9.

Rise time is defined as the amount of time taken by the rising edge to reach 70% amplitude from 30% aplitude for either SDA and SCL.

Higher PU resistor increases the rise time value, which is unacceptable if it crosses max limit mentioned in the spec.
Lower value decreases, but they also lead to higher current consumption, which is bad.

If very high PU value is used, the signal may not reach the Vih limit (Input Level High Voltage), in which case I have to either:
    1. decrease the PU resistance
    2. decrease the bus capacitance

Bus capacitance is a collection of all individual capacitance on the bus, such as:
    1. between SDA and SCL;
    2. parasitic capacitance;
    3. bus length;
    4. dielectric material;
    5. etc.

Table 10 shows the rise time and bus capacitance limits.

=========================================================================================================================================================
I2C Controller Receive Data API:
Check the Transfer Sequence Diagram for Controller Receiver in the Reference Manual.

Notes on the sequence:
    1. During EV5 event, the setting of SB flag to 1 indicates that the start generation was successful.
    2. Even though the Controller is receiving, the Controller is initiating the Address Phase and sending the 7-bit address with the R/W bit to the
        Peripheral. Peripheral sends ACK back.
    3. After EV6, data reception will happen -> shift register of the Controller will be filled with data bits.
    4. After 1 byte is received, Controller sends ACK back to Peripheral.
    5. The Controller code should always read the Data Register, only when the RXNE flag is set. (RXNE means Receive Buffer Not Empty)
    6. After the last data byte Controller sends back a NACK -> indication to the Peripheral to stop sending data.
    7. Controller generates the STOP condition.

The controller has to prepare to initiate STOP condition when last 2 bytes of data are remaining to be read on I2C.

=========================================================================================================================================================
I2C Interrupts:
Because our APIs are polling based, we haven't enabled control bits for Interrupt Events, so that they wouldn't trigger interrupts.

In I2C the overrun and underrun will not happen during clock stretching.

BTF flag prevents underrun and overrun.

In I2C, when you are transmitting, you can't receive and vice versa.

I2C has 2 ISR handling ways:
    1. Interrupt handling for interrupts generated by I2C events.
    2. Interrupt handling for interrupts generated by I2C errors.

=========================================================================================================================================================
I2C Peripheral Programming:
During the Peripheral Transmitter Transfer Sequence, when TXE = 1, then the Peripheral loads the data into the data register to be sent. (TXE = 1 is request for data.)

If ACK failure happens, it means that the controller does not want any more data from the peripheral.

STOPF flag is set only in peripheral receiver mode, which is set when controller initiates a STOP condition.

If ACK Failure is received, it is end of Tx.
If STOP generation is received, it is the end of Rx.
If TXE = 1, then peripheral needs to send 1 byte of data.
If RXNE = 1, then the application has received 1 byte.

TRA bit in the Status Register helps see if the device is in receiver or transmitter mode.

=========================================================================================================================================================
Common problems with I2C:
I2C Mandatory Tips: After I2C initialisation, probe SDA and SCL lines, as both must be held at HIGH voltage.

In a case that SDA and SCL are not held high:
    Check the activation of internal pull up resistors (software side: config reguster of I/O line)
        Might need to dump register contents.

ACK Failure can best be detected using a logic analyser.
    1. Might be generating address phase with a wrong peripheral address.
        This will cause a NACK -> verify the peripheral address.
    2. Might be that I did not enable the ACKing feature in the I2C Control Register
        Check the ACK enable field.

Controller is not able to produce clock:
    1. Check if I2C peripheral clock is enabled and set to at least 2MHz standard mode clock.
    2. Check if GPIO alternate functionality is configured properly for SDA and SCL lines.

=====================================================================================
I2C Interrupts:

We need to wait until the receive completes fully before moving on.

=========================================================================================================================================================
UART:
In synchronous transmission, the clock is separate from data and no start/stop bits are used. Therefore it is more efficient,
    as it avoids the use of extra bits like start/stop.

USART does not use a specific port, it works together with RS-232, RS-343, USB, etc.

USART Hardware Components:
    1. Baud rate generator
    2. Tx and Rx shift registers
    3. Tx/Rx control blocks
    4. Tx/Rx buffers
    5. FIFO buffer memory

USART is very powerful, but very expensive as well.

UART is bi-directional requiring at least 2 pins.
UART RX engine continously samples this line to detect the start bit of a frame. When it is detected, the frame reception is initiated.

RTS and CTS pins are required for hardware flow control.
CTS - Clear To Send (active low pin - when hardware flow control is used, Tx happens only when CTS is pulled low)
CTS has to be pulled low by another device.

RTS - Request To Send (active low pin)

One device's RTS is connected to another's CTS, which is why when RTS is pulled low, the CTS is pulled low as well, allowing for communication.

The data frame of UART can be configured to be from 5 to 9 bits. Word length can be chosen to be 9 bits or 8 bits, if parity bit is chosen.

Stop bit finishes the UART frame and it can be configured to be 1, 1.5 or 2 bit duration.

=========================================================================================================================================================
UART Baud Rate:

Baud rate tells how fast the data is sent in bits per second bps.
Inverting the baud rate shows how long it takes to transmit a single bit.

Baud rates can be any value, but Tx and Rx devices should operate at the same rate. (There are limits to how fast data can be transferred.)
Baud rates depend on the peripheral clock frequency of the UART peripheral.

USART Control Register 2 has a field called STOP, which defines how long is the stop bit: 1, 1.5 or 2 bits long.
If we have a high baudrate, then it might be wiser to have stop bit of 2 bits length.

The Rx engine is smart enough to detect start bits from IDLE data line going from high to low and 
    stop bits from ACTIVE data line going from low to high into IDLE state.

=========================================================================================================================================================
UART: Parity bit

Parity bits are the simplest method of error detection.

There can be 2 ways of parity:
    1. Even parity
    2. Odd parity

In case of even parity -> the parity bit is set to a 0 or 1 depending whether there is an even number of 1s in the data byte.
    1. If there is an odd number of 1s, then parity bit will be 1 to make the number of 1s into an even number.
    2. If there is an even number of 1s, then parity bit will be 0.

Parity bits work because, if a data byte is corrupted during data transmission, then we can look at the parity bit to see if it changed.
What happens when the data gets corrupted but the amount of 1s doesn't change?

=========================================================================================================================================================
UART: Tx

UART Shift Register is loaded with data from Tx Data Register (TDR) after the STOP bit is received.

UART: Data Tx steps (STM32F4xx based MCUs)
    1. Program the M bit in USART_CR1 to define the word length (8 or 9 bits)
    2. Program the number of stop bits in USART_CR2 register
    3. Select the desired baud rate using the USART_BRR register
    4. Set the TE bit in USART_CR1 to enable the transmit blocking
    5. Enable the USART by writing the Ue bit in USART_CR1
    6. Now if TXE flag is set, then write the data byte to send in the USART_DR register.
    7. After writing the last data into the USART_DR register, wait until TC=1.

=========================================================================================================================================================
UART: Rx

The data from UART Rx Shift Register is loaded into Rx Data Register once the stop bit is sampled.

UART: Data Rx steps
    1. Program the M bit in USART_CR1 to define the word length (8 or 9 bits)
    2. Program the number of stop bits in USART_CR2 register
    3. Select the desired baudrate using the USART_BRR register
    4. Enable the USART by writing the UE bit in USART_CR1
    5. Set the RE bit in the USART_CR1 register, which enables the receiver block of the USART peripheral
    6. When a character is received, wait till the RXNE bit is set and read the data byte from the data register
    7. The RXNE bit must be cleared by reading the data register, before the end of the reception of the next character to avoid
        an overrun error.

Instead of polling, we can use Rx in an interrupt mode, but instead of RXNE, we would have to work with RXNEIE.

Software reads from Data Register.

=========================================================================================================================================================
UART APIs:

UART User Configurable Items:
    USART_Mode
    USART_Baud
    USART_NoOfStopBits
    USART_WordLength
    USART_ParityControl
    USART_HWFlowControl

USART Driver APIs:
    USART Init / Peripheral Clock Control
    USART Tx
    USART Rx
    USART Interrupt Config & Handling
    Other USART management APIs

=========================================================================================================================================================
USART: Oversampling

Oversampling is used to recover data by distinguishing between incoming data and noise.
It can be either 8 or 16 times the baudrate.

Oversampling by 16 means that the receiver engine takes 16 samples over 1 bit time. Oversampling by 8 -> takes 8 samples.

The sampled value is 3 bit long, which means it can go up to 8.
If the sampled value is 0 or 8, then the received bit value is going to be 0 or 1.
If sample value is something else in between, the received bit will be either 0 or 1 (based on the "Noise Detection from Sampled Data" table),
    but most importantly, the Noise Error flag will be set to 1 (otherwise it's 0).

=========================================================================================================================================================
USART: Noise Error

When noise is detected in the frame:
    1. The Noise Error flag is set
    2. Invalid data is pushed into the DR
    3. It may be discarded or kept based on the application logic.

Depending on the oversampling method USART can work differently:
    1. If we are oversampling by 8,
        + we can reach higher baudrate
        - but the maximum receiver tolerance to clock deviation will be reduced.
    2. If we are oversampling by 16,
        + we get increased maximum receiver tolerance to clock deviation
        - we have smaller baudrate.

In very noisy environment, use the oversampling by 16.

====================================================================================

To supply the clock externally, it is possible to output clock signal via GPIO pins using RCC_CFGR register (RCC clock configuration register).
the RCC_CFGR register defines which clock is selected.

When turning on the External Oscillator, we need to wait until the HSE is ready by enabling the while loop to wait for the HSERDY bit is set.

=======================
SPI:

After sending data via SPI, we need to wait until the last byte is sent and only then close the SPI peripheral.
We need to check busy flag (BSY) for that in the Status Register (SR).

Dummy byte is necessary to be sent via SPI to the peripheral to fetch the response from the slave, so that we would see that the peripheral can ACK the request to communicate. Dummy byte is sent after the Command request to push out the ACK or NACK from the peripheral shift register.

If I am using 16 bit communication, then the dummy byte has to be 2 bytes in order to push out the ACK/NACK from peripheral.

SPI communication flow:
    1. Init GPIO and SPI and other peripherals.
    2. Config SSOE or SSI.
    3. Before sending data, enable the peripheral.
    4. Send the data
        When MCU sends data, it automatically receives garbage data from the other end. Let's say it sends 1 byte, it also receives 1 Byte
        of garbage data and RXNE status bit is set, which needs to be cleared to send new data. Therefore, we need to dummy read the MCU's
        Data Register to clear the RXNE bit.
    5. In order to receive some sort of response from the peripheral, we need to send a dummy byte or 2 bytes (depending on DFF) to
        push out the ACK/NACK response byte from the shift register of the peripheral. This way the ACK/NACK is received by the MCU which requested
        the data.

NOTE: SPI DOES NOT INITIATE COMMUNICATION.

Peripheral takes some time to read the analog value, thus the controller must wait some time before generating the dummy byte to fetch the result.
200 ms delay is too much usually for this analog read, but for Arduino it's ok.

=====================================================================
RTC LCD:

The RTC module has SCL Clock Frequency of 100 kHz max, thus we can't run the STM32 at fast speed, we need to run at standard speed.

Rise time of both SDA and SCL signals, which is 1000 ns, and capacitance load for each bus line, which is 400 pF, can be used to calculate the pull up resistor.

BSP (Board Support Package) layer contains API for user to control devices which are connected to the board (LCD, etc.) - it abstracts the usage of RTC and LCD.

BSP/ds1307.h contains device (RTC) related information:
    1. I2C address
    2. Register address
    3. Data structure to handle the information
    4. Function prototypes which are exposed to applications
    5. Application configurable items



