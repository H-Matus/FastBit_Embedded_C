To create a driver for a specific board:
1. Create a board level header (stm32f407xx.h)
    Place all base addresses for:
        1. Memory (SRAM, FLASH ROM, ROM)
        2. Buses in use (AHBx, APBx, etc.)
    Define peripheral addresses on each bus.
    Define peripheral register definition structures.
    Define clock register definition structure.
    Define peripherals (and clock) using peripheral addresses (while pointing to register definition)
    Create a clock definition;
    Define clock enable macros for peripherals by setting the correct bit on bus enable register which is pointed at by clock base address pointer (RCC->);
    Define clock disable macros.
    Define generic macros.
2. Create peripheral specific header (stm32f407xx_gpio_driver.h)
    Define config struct for peripheral (GPIO pins)
    Define handler struct for peripheral
    Define mode macros.
        For all registers that are to be used: MODE, TYPE, etc.
    Define peripheral function prototypes.
3. Create peripheral specific source
    Write the logic for peripheral functions.


GPIO_Init():

GPIO handler structure consists of the actual register address and GPIO pin config.
The config is used to take the data from user input on which GPIOs should be used and how.
Then during Init(), the config is passed into the register.

Before setting the GPIO register, we need to clear the value from the pin bits, which shall be set.


GPIO_DeInit():

We are aiming to reset all registers, for which we will be using the bus (AHBx, APBx) peripheral reset register.
In reset register, I need to set the bit of the register and revert it to 0 quickly.
Otherwise the register will be in reset state always.

do while loop is used to execute multiple statements in function macro.


GPIO_ReadFromInputPin():

Right shift the register until the required bit is the LSB. Mask it using 0x00000001 to get only the required bit.
And pass it out of the function.

GPIO Interrupts:

If the interrupt is registered and the CPU is already running an ISR, then priority will be compared.
The ISR with higher priority will be executed. If the running ISR is of lower priority, it will be put on hold.

Even if the interrupt is disabled, the interrupt arrives and gets registered in the Pending Register (PR),
though the ISR will not be executed.

Action steps of implementing an ISR function:
    1. Implement the ISR function. (just a C function)
    2. Store the address of your ISR at the vector address location corresponding to the IRQ number, for which you have written the ISR.

Weak ISRs:
A lot of ISRs have already been implemented as weak ISRs in startup code, which means that I have to override them manually.

ISRs should be implemented in the application level.
I should use the IRQ handler name based on the ones defined in startup code, as function name and inside of it, call the 
according peripheral IRQHandling().

Example:
void EXTI0_IRQHandler(void)
{
    GPIO_IRQHandling(0); /* 0 is the pin number, which will be detecting interrupt requests (IRQs) */
}

The address of EXTI0_IRQHandler() function should be stored at the vector address of the corresponding IRQ number.


STM32 GPIO Pin Specifications:
Vdd is the main power supply of the micrcontroller. Provided externally through Vdd pins of the microcontroller.
Vdd is 1.8V <= Vdd <= 3.6V; Max Voltage = 4V.
Vss is ground reference and should be kept at 0V. Minimum Vss is -0.3V.

Most pins on STM32 boards are either TT (Three-volt Tolerant) or FT (Five-volt Tolerant) pins.
Three-volt Tolerant pins are operating under -0.3V <= Vin(TTa) <= Vdd+0.3V

I/O source current is 25mA Max.

Sink current is a max current which can be sunk in to Vss by a GPIO output pin when LOW.
Sink current is 25 mA. If it's more then the pin might get damaged.
Ivdd is 240 mA, so the maximum current drawn by all pins can be 240 mA.
If I configure board pins to output 1 on 20 pins, then each pin will output 12mA of current, as 240/20 = 12.
The sum of all currents that are being sinked, has to be lower than 240 mA.

Injection current is the current that is being forced into a pin by an input voltage (Vin) higher than the positive supply (Vdd) or lower than ground (Vss).
Injection current higher than given specification causes a current flow inside the device and affects its reliability. Even tiny current exceeding the specified
limit is not allowed.

Negative-injection current is the current induced when Vin < Vss.
The maximum negative injected current is -5mA, and the minimum Vin voltage level acceptable on the GPIO is -0.3V for TT and FT GPIO.

Positive-injection current is the current induced when Vin > Vdd.
For STM32 devices, the max positive-injection current on FT GPIO is defined as N/A or 0 mA.

===================================================================================================================
SPI:

SPI is used to communicate between the MCU and peripherals, such as sensors, EEPROM, SDCard, display, Bluetooth, etc.
It has 4 lines:
    1. SCLK - clock
    2. MOSI - output
    3. MISO - input
    4. SS - slave select - selects which peripheral the MCU is talking to.

===================================================================================================================
Three-state logic:

Tri-state allows an output or input pin/pad to assume a high impedance state, which basically disconnects the pin/pad from the external circuit,
in addition to the 0 and 1 logic levels.

This allows multiple circuits to share the same output line or lines. (Like a bus which cannot listen to more than one device at a time)

===================================================================================================================

SPI (continued):

Communication protocols such as I2C, SPI, USB, etc. have 3 different types of data transmitting or receiving methodologies:
    1. Polling based (blocking call)
    2. Interrupt based (non-blocking type call)
    3. DMA based

Each of the peripheral has one or two control registers.

In the reference manual, communication peripheral control registers have a BR bit field, which stands for Baudrate.
It defines at what speed the peripheral is operating.

MSTR will be 0 by default, which means that the peripheral will be configured in peripheral mode automatically.
I have to make it as 1 in order to make my peripheral a Main. Only when I make it as a Main, it will produce the serial clock.
DEBUGGING TIP: If I see that the peripheral is not producing clock, then it should be in peripheral/slave mode.

If I want a simplex communication, then I may have to check the 10th bit, as it describes RX ONLY bit.
Some bits are combined like RXONLY, BIDI MODE, BIDIOE:
    1. BIDI MODE defines if bidirectional data is enabled or 2 line unidirectional is enabled.
    2. BIDIOE defines whether the direction is RX or TX (this only works with bidirectional mode).
    3. RXONLY is combined with BIDI MODE in 2-line unidirectional mode to say whether the mode is Full duplex or output is disabled (RX only).

If I want to have SIMPLEX only communication, I have to make RXONLY bit as 1.

FULL DUPLEX communication has 2 unidirectional lines:
    1. MISO -> MISO
    2. MOSI -> MOSI

To make SIMPLEX out of FULL DUPLEX just disconnect the MISO line.
To make SIMPLEX receive only out of FULL DUPLEX, we can't just disconnect the MOSI line, we have to activate the SCLK line as well.
    In SPI Communication, slave will not initiate data transfer unless master produces clock.

Since the MOSI is deactivated, master will not produce clock on serial clock, because in SPI communication, the clock is produced 
only when data is produced on the MOSI line.
Because of this we have to force the main to produce clock on SCLK.
We do that by setting the RXONLY bit, to the receive only mode.

Software Peripheral Management (SSM) is disabled by default, which means that peripherals are selected using hardware wires.

=========================================================================================================================================================
SPI Init:
The device mode is defined in MSTR bit field of Control Register (CR1).

SPI Data Send:
Firmware does not have access to buffers, thus it is accessed by using SPI_DR register (Data Register).
In receiving mode, the data comes from RX buffer into the Data Register from where the firmware reads it.
In transmission mode, the data from Data Register is copied over to the TX buffer.
Before writing to the Data Register, make sure that the TX buffer is empty - check the TXE flag and before reading the register, check the RXNE flag.

Write SPI flags under the spi_driver.h

I2C requires GPIO open drain configuration, while SPI doesn't require anything, thus push-pull shall be used for SPI with no pull-up/pull-down config.

To send data via SPI, both GPIO and SPI must be initialised.

After SPI2_Inits(), all the required configurations are loaded into the control registers, but the SPI peripheral is not enabled because of that.
The SPI configs must be loaded into registers, while the SPI is disabled.
We have to explicitly enable SPI, by enabling the SPE bit in SPIx_CR. SPE is 0 by default.
When you enable SPI peripheral, the SPI peripheral will be busy in data communcation, in which case the SPI peripheral will not accept any changes
    made to the control registers.

=========================================================================================================================================================
SPI Receive Data:
Process of receiving data on SPI:
    1. Check if Len is 0;
        Yes: Exit from the function and end;
        No: Wait until the Rx Buffer is non-empty;
    2. What value is DFF?:
        0: Read Data Register for 1 byte of data and increment the rx buffer address
            Then decrement Len, as one 1 byte has been read.
        1: Read Data Register for 2 bytes of data and increment the rx buffer address
            Then decrement Len twice, as 2 bytes if data have been read.
    3. Return to 1.

=========================================================================================================================================================
SPI Interrupts:
During SPI communication, interrupts can be generated by the following events:
    1. Transmit Tx buffer ready to be loaded
    2. Data received in Rx buffer
    3. Master mode fault (in single master case you must avoid this error happening)
    4. Overrun error

Interrupts can be enabled and disabled separately.

Master mode fault may occur when the SPI comms are used in multi-master configuration.
Overrun error flag may be set up in the status register and interrupts may be triggered.

The control register controls during which events the interrupt shall be triggered.
If TXEIE is set to 1 in control register, then the interrupt will be triggered when the TXE is set.
By default, TXEIE is 0, which means that by default TXE flag will not set off an interrupt.

SPI_1 is connected to NVIC at some IRQ number. If we have 5 SPI peripherals, then we will have 5 different IRQ lines connected to NVIC.

SPI ISR handling:
    1. Enter ISR
    2. Understand which event caused interrupt to trigger (check SR)
        a. Interrupt is due to setting of RXNE flag -> Handle RXNE event
        b. Interrupt is due to setting of TXE flag -> Handle TXE flag
        c. Interrupt is due Setting of ERROR flag -> Handle Error

Handling TXE Interrupt:
    1. 8-bit or 16-bit mode?
        8-bit: Write one byte to SPI Data Register (DR) -> Decrement Len by 1
        16-bit: Write 2 byte to SPI Data Register (DR) -> Decrement Len by 2
    2. Is Len = 0?
        Yes: Close the SPI TX
        No: Wait till another TXE interrupt

Overrun error definition:
Overrun condition occurs when the master or the slave completes the reception of the next data frame,
while the read operation of the previous frame from the Rx buffer has not completed (case RXNE flag is set).
In such case the SPI peripheral will discard the new data byte that is arrived and we will lose the data.

Read operation of SPI_DR returns the frame previously received.

To clear the OVR bit, we need to perform read access to the SPI_DR register followed by a read access to the SPI_SR register.

(Private functions should have their prototypes in source files (.c), as they are not supposed to be used as API by users)

After operations with temp variable, I can typecast it to (void), as it is unused.

=========================================================================================================================================================
Common Problems with SPI and debugging tips:

Master moed bit must be enabled in the configuration register if you are configurating the peripheral as master.
SPI peripheral enable bit must be enabled.
SPI peripheral clock must be enabled. By default clocks to almost all peripheral in the microcontroller will be disabled to save power.

Cases:
    1. Master is not able to produce clock and data.
        a. GPIOs are not configured properly for SPI (Alternate) functionality -> Recheck the GPIO Configuration registers to see what values they have.
        b. Because of Configuration Overriding -> Dump out all the required register contents just before you begin the transmission.
    2. Master is sending data, but slave is not receiving data;
        a. Not pulling down the slave select pin to ground before sending data to the slave -> probe through the logic analyser to confirm 
            slave select line is really low during data communication.
        b. GPIOs are not configured properly (alternate functionality) -> probe the alternate function register
        c. Not enabling the peripheral IRQ number in the NVIC -> Probe the NVIC interrupt mask register to see whether the bit position
            corresponding to the IRQ number.
    3. SPI interrupts are not getting triggered.
        a. Not enabling the TXE or RXNE interrupt in the SPI configuration register -> Check the SPI configuration register 
            to see TXEIE and RXNEIE bits are really set to enable the interrupt.
        b. Not enabling the peripheral IRQ number in the NVIC -> Probe the NVIC Interrupt Mask Register 
            to see whether the bit position corresponding to the IRQ number is set or not.
    4. Master is producing right data but slave is receiving the different data.
        a. Using long wires in high frequency communication -> use shorter wires or reduce the SPI serial frequency to 500kHz to check things work well.
        
==============================================================================================================================================================
I2C:
It is a protocol to achieve serial data communication between integrated circuits (ICs) which are very close to each other.
It's a more serious protocol than SPI because companies have come forward to design a specification for it.

I2C protocol details (how data should be sent, received, what's the handshake, error handling, etc.) are more complex than SPI. 
(SPI is simple when compared to I2C)

I2C spec is designed by NXP. SPI doesn't have a spec.

I2C protocol is multi-master capable, whereas SPI has no guidelines to achieve this, but depends on MCU designers.
STM SPI peripherals can be used in multi master configuration but arbitration should be handled by software code.

I2C hardware automatically ACKs (acknowledges) every byte received. SPI does not support any automatic ACKing.

I2C requires only 2 pins: SDA and SCL.
I2C master talks to peripherals based on peripheral addresses, whereas in SPI dedicated pin is used to select the slave.

I2C is half duplex, whereas SPI is full duplex.

I2C max speed is 4MHz in ultra speed plus mode. For some STM microcontrollers the max speed is just 400 kHz.
SPI max speed is Fpclk/2. That means if the peripheral clock is 20 MHz, then speed can be 10 MHz.

In I2C, peripheral can make controller wait by holding the clock down if it's busy, thanks to clock streching feature of I2C.
In SPI, peripheral has no control over clock, programmers may use their own tricks to overcome this situation.

Data rate is a number of bits transferred from sender to receiver in 1 sec.
SPI is a lot faster in this regard than I2C.

Terminology:
    1. Controller - the device which initiates a transfer, generates clock signals and terminates a transfer.
    2. Peripheral - the device addressed by a master.
    3. Multi-controller - more than one controller can attempt to control the bus at the same time without corrupting the message.
    4. Arbitration - procedure to ensure that, if more than one controller simultaneously tries to control the bus, only one is allowed to do so 
        and the winning message is not corrupted.
    5. Synchronization - procedure to synchronize clock signals of two or more devices.

Both SDA and SCL are bidirectional lines connected to a positive supply voltage via pull-up resistors. When the bus is free, both lines are held at HIGH.
The output stages of devices connected to the bus must have an open-drain or open-collector configuration.
The bus capacitance limits the number of interfaces connected to the bus.

For I2C pins to function properly, pull-up resistor value shall be calculated according to the I2C formula.

SDA and SCL pins have to be in Open-Drain configuration with either an internal or external pull-up resistor.

When the bus is idle, both SDA and SCL are pulled to +Vdd.
Whenever you face problems in I2C, probe the SDA and SCL lines after I2C initialisation. It must be held at HIGH. (3.3V or 1.8V)

I2C modes:
    1. Standard     - Up to 100 Kbits/s - Supported by STMf2F4x
    2. Fast         - Up to 400 Kbits/s - Supported by STMf2F4x
    3. Fast+        - Up to   1 Mbits/s - Supported by some STMf2F4x MCUs (refer to RM)
    4. High Speed   - Up to 3.4 Mbits/s - Not supported by F4x

Standard mode was the first mode released with I2C.
Standard mode devices are not upward compatible, as they can't communicate with devices of fast mode or above.

Fast-mode devices are downward-compatible and can communicate with standard-mode devices in a 0-100 kbit/s I2C bus system.
Standard-mode devices should not be introduced in a fast-mode I2C-bus system. Such introduction can cause unpredictable states.
To achieve higher data transfer rates, I2C devices shall be put in to a fast mode in configs.


Basics of I2C protocol:
The data transfer is always initiated by the controller on SDA line. 

The process of SDA:
    1. Controller initiates the data transfer by first producing the start condition.
    2. Address phase starts, during which first 7 bits is the address of the peripheral.
    3. The remaining last bit decides the read or write operation.
        If bit is 0 -> controller is going to write the data (WRITE)
        If bit is 1 -> controller is going to read the data (READ)

Every iteration put on SDA line, must be 8 bits long.
Each byte must be followed by an ACK bit.
    When peripheral gets the 8bits, it then sends back an ACK bit, which the controller receives.
    If the R/W bit is 0 (WRITE), then after ACK, peripheral receives data byte, after which the peripheral sends an ACK again, 
    saying that it received the data byte.
Data is transferred with the Most Significant Bit (MSB) first.

When controller decides to stop communication with peripheral, then STOP condition is generated.
When stop condition is generated, then the controller is no longer in control of the bus and another controller/same controller can take control of it.

Address phase is the combination of peripheral address and R/W bit.


START and STOP:
All comms begin with a START (S) and a STOP (P).

A HIGH to LOW transition on the SDA line while SCL is HIGH defines a START condition.
A LOW to HIGH transition on the SDA line while SCL is LOW defines a STOP condition.

Once controller generates the START condition successfully it actually claims the bus so that no other controller can claim the bus.
Other controllers should wait until bus is released.

After STOP condition, both SDA and SCL are released -> they are in pull-up condition.

When SDA is low, then it is activated, because by default it is pulled high.
If the state of SDA is low at this position then it is considered as ACK otherwise it's NACK.

Repeated START (Sr) is a START condition, which did not require a stop condition to be engaged.


STOP condition timings:
Setup Time for Stop Condition (Tsu;sto) is measured as the time between 70% amplitude of the rising edge of SCL and 30% amplitude of a rising SDA signal
during a stop condition.


I2C Points to remember:
START and STOP conditions are always generated by the controller.
The bus is considered to be busy after the START condition.

The bus is considered to be free again a certain time after the STOP condition.

When the bus is free another controller(if present) can get the chance to claim the bus.

The bus stays busy if a repeated START (Sr) is generated instead of a STOP condition.

Most of the MCUs I2C peripherals support both controller and peripheral mode.
You need not to configure the mode because when the peripheral generates the start condition it automatically becomes
    the controller and when it generates the STOP condition it goes back to peripheral mode.


I2C Address Phase:
The transmitter releases the SDA line during the ACK clock pulse so the receiver can pull the SDA line LOW and it remains stable LOW
    during the HIGH period of this clock pulse.

IMPORTANT:
    1. The ACK takes place after every byte.
    2. The ACK bit allows the receiver to signal the transmitter that the byte was successfully received and another byte may be sent.
    3. The controller generates all clock pulses, includeing the ACK ninth clock pulse.

When SDA remains HIGH during this 9th clock pulse, this is defined as the NACK signal.
The controller can then generate either a STOP condition to abort the transfer, or a repeated START condition to start a new transfer.


I2C Data Validity:
The data on the SDA line must be stable during the HIGH period of the clock. The HIGH or LOW state of the data line can only change when
    the clock signal on the SCL line is LOW. One clock pulse is generated for each data bit transferred.

Data changes only when the clock is high.